{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Designing Data-Intensive Applications","text":"<p>Listen up bookworms! If you're part of the Recurse Center book club, I've got some juicy notes for you all about that DDIA book. You know, the one about data-intensive applications? Yeah, that's the one. So, get your reading glasses on and your thinking caps ready, because we're about to explore the wonderful world of data in a fun and informative way. Let's go!</p> <p>\"Designing Data-Intensive Applications\" by Martin Kleppmann is a comprehensive guide to the principles, challenges, and trade-offs involved in building data-intensive systems. The book is divided into three parts, covering the foundations of data systems, data storage and retrieval, and distributed systems. Here's a summary of each chapter:</p> <p>Part I: Foundations of Data Systems </p> <p>Chapter 1: Reliable, Scalable, and Maintainable Applications</p> <ul> <li>Introduces the three key attributes of good data systems: reliability, scalability, and maintainability</li> <li>Discusses the trade-offs and challenges involved in achieving these attributes</li> </ul> <p>Chapter 2: Data Models and Query Languages</p> <ul> <li>Discusses the different data models used in data systems, such as relational, document-oriented, and graph databases</li> <li>Introduces query languages used to retrieve data from these models</li> </ul> <p>Chapter 3: Storage and Retrieval</p> <ul> <li>Discusses different types of storage systems, such as file systems, relational databases, and NoSQL databases</li> <li>Introduces the concept of indexing and its importance in data retrieval</li> </ul> <p>Chapter 4: Encoding and Evolution</p> <ul> <li>Discusses the importance of data encoding and the challenges of evolving data formats over time</li> <li>Introduces different encoding formats, such as JSON, Protocol Buffers, and Avro</li> </ul> <p>Data Chapter 5: Replication</p> <ul> <li>Discusses the importance of replication for availability, fault tolerance, and scalability</li> <li>Introduces different replication strategies, such as single-leader and multi-leader replication</li> </ul> <p>Chapter 6: Partitioning</p> <ul> <li>Discusses the challenges of partitioning data in a distributed system</li> <li>Introduces different partitioning strategies, such as range partitioning and hash partitioning</li> </ul> <p>Chapter 7: Transactions</p> <ul> <li>Discusses the importance of transactions for data consistency in a distributed system</li> <li>Introduces different transaction models, such as two-phase commit and optimistic concurrency control</li> </ul> <p>Chapter 8: The Trouble with Distributed Systems</p> <ul> <li>Discusses the challenges and trade-offs involved in designing and operating distributed systems, such as network partitions and consistency trade-offs</li> </ul> <p>Part III: Derived Data Chapter 9: Batch Processing</p> <ul> <li>Introduces batch processing and the challenges of processing large amounts of data efficiently</li> <li>Introduces batch processing frameworks, such as Hadoop and Spark</li> </ul> <p>Chapter 10: Stream Processing</p> <ul> <li>Discusses the importance of stream processing for real-time data processing</li> <li>Introduces stream processing frameworks, such as Apache Kafka and Apache Flink</li> </ul> <p>Chapter 11: The Future of Data Systems</p> <ul> <li>Discusses the emerging trends in data systems, such as serverless computing and machine learning</li> <li>Discusses the challenges and opportunities presented by these trends</li> </ul> <p>Overall, \"Designing Data-Intensive Applications\" provides a comprehensive overview of the principles, challenges, and trade-offs involved in building data-intensive systems. The book is a must-read for anyone involved in designing, building, or operating data systems.</p>"},{"location":"chapter1/","title":"Chapter 1","text":"<ol> <li>Reliable, Scalable, and Maintainable Applications</li> </ol>"},{"location":"chapter1/#nonfunctional","title":"NonFunctional","text":"<p>Nonfunctional requirements include qualities such as performance, reliability, availability, scalability, maintainability, security, usability, and many others. These attributes are often critical for the success of a system and should be considered and prioritized alongside the system's functional requirements.</p> <p>Performance, for example, refers to the system's ability to respond to user requests within an acceptable time frame. Reliability refers to the system's ability to function correctly and consistently over time. Scalability refers to the system's ability to handle increasing amounts of work or traffic without a decrease in performance. Maintainability refers to the ease with which the system can be maintained, updated, or modified over time.</p> <p>Usability refers to the ease with which users can interact with the system and accomplish their tasks. Security refers to the system's ability to protect against unauthorized access or attacks.</p> <p>Nonfunctional requirements are often measured and evaluated using specific metrics or benchmarks, such as response time, availability percentage, or defect rate. These metrics can be used to track and monitor the system's performance over time and identify areas for improvement.</p> <p>Overall, nonfunctional requirements are an important aspect of system design and should be considered and prioritized alongside the system's functional requirements.</p>"},{"location":"chapter1/#reliability","title":"Reliability","text":"<p>In the context of building data-intensive applications, reliability refers to the ability of a system to operate correctly even in the presence of faults. Chapter 1 of \"Designing Data-Intensive Applications\" by Martin Kleppmann provides an overview of the techniques and technologies used to achieve reliability in data systems.</p> <p>The chapter discusses different types of faults that can occur in a system, such as hardware faults, software faults, and human errors. It introduces the concept of fault tolerance, which involves designing a system to continue functioning even when faults occur.</p> <p>One technique for achieving fault tolerance is replication, which involves creating multiple copies of data or processes and distributing them across multiple machines. The chapter discusses different replication strategies, such as single-leader replication and multi-leader replication. It also introduces the concept of quorums, which are used to ensure consistency between replicas.</p> <p>The chapter also discusses other techniques for achieving reliability, such as redundancy, isolation, and versioning. It introduces the CAP theorem, which states that it is impossible for a distributed system to simultaneously provide consistency, availability, and partition tolerance. The chapter explains the trade-offs involved in choosing between these attributes and discusses different strategies for balancing them.</p> <p>Overall, the Reliable section of \"Designing Data-Intensive Applications\" emphasizes the importance of reliability in data systems and introduces techniques for achieving fault tolerance and consistency. The section lays the foundation for the rest of the book, which goes into more detail on the different technologies and architectures used to build reliable, fault-tolerant data systems.</p>"},{"location":"chapter1/#scalability","title":"scalability","text":"<p>In the context of building data-intensive applications, scalability refers to the ability of a system to handle increasing amounts of work or traffic without a decrease in performance. Chapter 1 of \"Designing Data-Intensive Applications\" by Martin Kleppmann provides an overview of the techniques and technologies used to achieve scalability in data systems.</p> <p>The chapter discusses the challenges of achieving scalability, such as the need for parallelism, load balancing, and partitioning. It introduces the concept of vertical scaling, which involves increasing the resources of a single machine to handle more work, and horizontal scaling, which involves distributing work across multiple machines.</p> <p>The chapter discusses different types of partitioning strategies, such as range partitioning and hash partitioning. It explains how partitioning can help to achieve scalability by allowing data to be distributed across multiple machines and processed in parallel.</p> <p>The chapter also introduces the concept of load balancing, which involves distributing work evenly across multiple machines to avoid overloading any one machine. It discusses different load balancing strategies, such as round-robin and least connections, and explains how load balancing can help to achieve scalability and improve performance.</p> <p>Overall, the Scalability section of \"Designing Data-Intensive Applications\" emphasizes the importance of scalability in data systems and introduces techniques for achieving it. The section lays the foundation for the rest of the book, which goes into more detail on the different technologies and architectures used to build scalable, high-performance data systems.</p>"},{"location":"chapter1/#maintainability","title":"maintainability","text":"<ul> <li>devops</li> <li>https://en.wikipedia.org/wiki/Spaghetti_code</li> </ul> <p>In the context of building data-intensive applications, maintainability refers to the ability of a system to be easily maintained and updated over time. Chapter 1 of \"Designing Data-Intensive Applications\" by Martin Kleppmann provides an overview of the techniques and technologies used to achieve maintainability in data systems.</p> <p>The chapter discusses the challenges of achieving maintainability, such as the need for modularity, abstraction, and encapsulation. It introduces the concept of software architecture, which involves breaking a system down into components that can be developed and maintained independently. It discusses different architectural styles, such as layered architecture and microservices architecture, and explains how they can help to achieve maintainability.</p> <p>The chapter also introduces the concept of version control, which is a technique for tracking changes to source code over time. It discusses different version control systems, such as Git and Subversion, and explains how they can help to achieve maintainability by making it easier to track and manage changes to a system's codebase.</p> <p>The chapter emphasizes the importance of testing and debugging in achieving maintainability. It introduces different types of testing, such as unit testing and integration testing, and explains how they can help to identify and prevent bugs in a system. It also discusses the importance of monitoring and logging, which can help to identify and diagnose problems in a running system.</p> <p>Overall, the Maintainability section of \"Designing Data-Intensive Applications\" emphasizes the importance of maintainability in data systems and introduces techniques for achieving it. The section lays the foundation for the rest of the book, which goes into more detail on the different technologies and architectures used to build maintainable, adaptable data systems.</p>"},{"location":"chapter2/","title":"Chapter 2","text":"<p>Data Models and Query Languages</p> <p>The limits of my language mean the limits of my world. \u2014Ludwig Wittgenstein, Tractatus Logico-Philosophicus (1922)</p> <p>Chapter 2 focuses on data models and query languages, which serve as the foundation for understanding how various databases and systems are designed to store, organize, and retrieve data.</p>"},{"location":"chapter2/#data-models","title":"Data Models:","text":"<p>Data models are abstract representations of how data is organized and structured. They are essential for ensuring that data is stored efficiently and can be easily accessed and manipulated. The chapter discusses three primary data models:</p> <p>a. Relational Model: Introduced by E.F. Codd in 1970, the relational model organizes data in tables (relations) consisting of rows (tuples) and columns (attributes). It is the basis for SQL databases, which are widely used in various applications.</p> <p>b. Document Model: This model stores data in semi-structured formats like JSON or XML. It is schema-less, allowing more flexibility in data representation and is often used in NoSQL databases like MongoDB and Couchbase.</p> <p>c. Graph Model: The graph model represents data as nodes (entities) and edges (relationships). It is particularly suitable for representing complex relationships, such as social networks or recommendation systems. Graph databases like Neo4j and ArangoDB utilize this model.</p>"},{"location":"chapter2/#query-languages","title":"Query Languages:","text":"<p>Query languages are used to interact with databases and retrieve or manipulate data. They help bridge the gap between human-readable queries and low-level data storage. The chapter discusses several query languages for different data models:</p> <p>a. SQL (Structured Query Language): SQL is a declarative query language used primarily for relational databases. It allows users to specify what data they want, rather than how to retrieve it.</p> <p>b. MapReduce: A functional programming model used for processing large-scale data across distributed systems. It involves two primary functions - Map (transforming data) and Reduce (aggregating results).</p> <p>c. NoSQL Query Languages: Various NoSQL databases have their query languages, such as MongoDB's JSON-based query language or Cypher for Neo4j.</p> <p>d. GraphQL: A query language for APIs, allowing clients to request specific data from a server. It enables more efficient and flexible data retrieval.</p>"},{"location":"chapter2/#relational-model-versus-document-model","title":"Relational Model Versus Document Model","text":"<p>the section on the relational model versus the document model highlights the fundamental differences between these two data models and their respective use cases.</p> <ol> <li>Relational Model:</li> </ol> <p>The relational model organizes data in tables (relations) with rows (tuples) and columns (attributes). Each row represents an entity and columns represent its attributes. This model is based on a strict schema, ensuring consistency in data representation. Relational databases, such as PostgreSQL and MySQL, use SQL for querying data. </p> <p>Advantages:</p> <p>a. Schema enforcement, which ensures consistency. b. Support for complex joins, which enables querying related data across multiple tables. c. Wide adoption and mature ecosystem.</p> <p>Disadvantages:</p> <p>a. Limited flexibility in handling hierarchical and complex data structures.</p> <p>b. Potential performance issues with joins, especially for large-scale data.</p> <ol> <li>Document Model:</li> </ol> <p>The document model stores data in semi-structured formats, such as JSON or XML. It allows for schema-less or schema-flexible storage, providing more flexibility in data representation. Document databases, such as MongoDB and Couchbase, use specialized query languages tailored to their data structures.</p>"},{"location":"chapter2/#advantages","title":"Advantages:","text":"<p>a. Greater flexibility in handling diverse and evolving data structures.</p> <p>b. Better performance for read-heavy workloads and simpler data access patterns, as related data can be stored together in a single document.</p> <p>c. Easier to scale horizontally due to the denormalized nature of data storage.</p>"},{"location":"chapter2/#disadvantages","title":"Disadvantages:","text":"<p>a. Lack of schema enforcement can lead to data inconsistency.</p> <p>b. Limited support for complex joins, making it challenging to query related data across multiple documents.</p> <p>The choice between the relational and document model depends on the specific requirements of the application. The relational model is more suitable for applications that require strict consistency, complex querying, and transactional support. In contrast, the document model is more appropriate for applications that need flexibility in data representation, faster read operations, and simpler access patterns.</p>"},{"location":"chapter2/#summary","title":"Summary","text":"<p>Data models are a huge subject, and in this chapter we have taken a quick look at a broad variety of different models. We didn\u2019t have space to go into all the details of each model, but hopefully the overview has been enough to whet your appetite to find out more about the model that best fits your application\u2019s requirements.</p> <p>Historically, data started out being represented as one big tree (the hierarchical model), but that wasn\u2019t good for representing many-to-many relationships, so the relational model was invented to solve that problem. More recently, developers found that some applications don\u2019t fit well in the relational model either. New nonrelational \u201cNoSQL\u201d datastores have diverged in two main directions:</p> <ol> <li>Document databases target use cases where data comes in self-contained docu\u2010 ments and relationships between one document and another are rare.</li> <li>Graph databases go in the opposite direction, targeting use cases where anything is potentially related to everything.</li> </ol>"},{"location":"chapter2/#questions-during-review","title":"Questions during review","text":"<p>Declarative SQL (also known as the query language) is a way to describe what you want without specifying how to achieve it. In contrast, imperative SQL (also known as the data manipulation language) consists of statements that describe the actions you want to perform on the data.</p> <p>Here's an example of declarative SQL:</p> <pre><code>-- Declarative SQL: Query to get the names of all employees who work in the 'Finance' department\nSELECT employees.name\nFROM employees\nJOIN departments ON employees.department_id = departments.id\nWHERE departments.name = 'Finance';\n</code></pre> <p>In this example, you describe what you want (names of employees in the Finance department) without specifying how to achieve it. The SQL engine is responsible for determining the best way to execute the query and retrieve the desired data.</p> <p>Here's an example of imperative SQL:</p> <pre><code>-- Imperative SQL: Insert a new employee into the 'employees' table\nINSERT INTO employees (name, age, department_id)\nVALUES ('John Doe', 30, 1);\n\n-- Imperative SQL: Update an employee's name in the 'employees' table\nUPDATE employees\nSET name = 'Jane Doe'\nWHERE id = 1;\n\n-- Imperative SQL: Delete an employee from the 'employees' table\nDELETE FROM employees\nWHERE id = 1;\n</code></pre> <p>In these imperative SQL examples, you are specifying the actions to perform on the data: insert a new employee, update an existing employee's name, and delete an employee. The SQL engine performs these actions directly on the data without having to determine how to achieve the desired outcome.</p> <p>Note that the distinction between declarative and imperative SQL is not strict, and the terms are not always used in the same way by everyone. The examples provided here are meant to illustrate the general idea of declarative SQL as focusing on the desired outcome without specifying how to achieve it, whereas imperative SQL focuses on the actions to be performed on the data.</p>"},{"location":"chapter2/#further-clarification","title":"Further clarification","text":"<p>Is it fair to say SQL is both imperative and declarative? Maybe not, maybe yes.. </p> <p>SQL is primarily a declarative language. However, when it comes to working with stored procedures or triggers, procedural SQL extensions like PL/SQL (in Oracle) or T-SQL (in SQL Server) are used, which have imperative programming constructs.</p> <p>These procedural extensions allow you to use control structures like loops, conditional statements, and error handling within the database environment, making it possible to create more complex, imperative-style logic.</p> <pre><code>\n-- T-SQL: Create a stored procedure to update the salary of employees in a specific department\nCREATE PROCEDURE UpdateSalaryByDepartment\n    @DepartmentName NVARCHAR(50),\n    @SalaryIncrease DECIMAL(5, 2)\nAS\nBEGIN\n    -- Declare a variable to hold the department ID\n    DECLARE @DepartmentId INT;\n\n    -- Get the department ID\n    SELECT @DepartmentId = id\n    FROM Departments\n    WHERE name = @DepartmentName;\n\n    -- Check if the department ID is not NULL\n    IF @DepartmentId IS NOT NULL\n    BEGIN\n        -- Update the salary of employees in the specified department\n        UPDATE Employees\n        SET salary = salary * (1 + @SalaryIncrease)\n        WHERE department_id = @DepartmentId;\n    END\n    ELSE\n    BEGIN\n        -- Raise an error if the department is not found\n        RAISERROR('The specified department does not exist.', 16, 1);\n    END\nEND;\n\n</code></pre> <p>In this T-SQL example, we create a stored procedure to update the salary of employees in a specific department. The procedure uses imperative constructs like variable declaration, conditional statements (IF-ELSE), and error handling (RAISERROR) to implement the logic.</p>"},{"location":"chapter2/#how-is-the-data-stored-in-nosql-db","title":"How is the data stored in nosql dB?","text":""},{"location":"chapter5/","title":"Chapter 3","text":""},{"location":"chapter5/#part-ii-distributed-data","title":"Part II: Distributed Data","text":""},{"location":"chapter5/#big-picture","title":"Big Picture","text":"<ul> <li>https://github.com/donnemartin/system-design-primer#master-slave-replication </li> </ul>"},{"location":"chapter5/#chapter-5-replication","title":"Chapter 5: Replication","text":"<ul> <li>5.1 Leaders and Followers</li> <li>5.2 Synchronous Versus Asynchronous Replication</li> <li>5.3 Setting Up New Followers</li> <li>5.4 Handling Node Outages</li> <li>5.5 Implementation of Replication Logs</li> <li>5.6 Problems with Replication Lag</li> <li>Reading Your Own Writes</li> <li>Monotonic Reads</li> <li>Consistent Prefix Reads</li> <li>5.10 Solutions for Replication Lag</li> </ul>"},{"location":"chapter5/#replication-in-distributed-systems","title":"Replication in Distributed Systems","text":"<ol> <li> <p>Replication: Keeping a copy of the same data on multiple machines connected via a network. Reasons for replication:    a. Reduce latency by keeping data geographically close to users    b. Increase availability by allowing the system to work despite part failures    c. Increase read throughput by scaling out the number of machines serving read queries</p> </li> <li> <p>Assumptions: Each machine can hold a copy of the entire dataset. Chapter 6 discusses partitioning for larger datasets.</p> </li> <li> <p>Replication challenges arise when handling changes to replicated data.</p> </li> <li> <p>Three popular replication algorithms:    a. Single-leader    b. Multi-leader    c. Leaderless replication</p> </li> <li> <p>Each has pros and cons, which are examined in detail.</p> </li> <li> <p>Replication trade-offs:    a. Synchronous vs. asynchronous replication    b. Handling failed replicas</p> </li> <li> <p>These are often database configuration options with similar principles across implementations.</p> </li> <li> <p>Replication principles haven't changed much since the 1970s due to fundamental network constraints.</p> </li> <li> <p>Developers often misunderstand issues such as eventual consistency. The chapter also discusses read-your-writes and monotonic reads guarantees.</p> </li> </ol>"},{"location":"chapter5/#single-leader-diagram","title":"Single Leader Diagram","text":"<pre>\n        +---------+\n        |         |\n        |  User   |\n    [1] O&lt;--------| +Picture|\n       /|\\        |         |\n        |         +---------+\n        |             |\n        |             v\n        |\n    [2] +----------------------+\n        |                      |\n        | Write/Read Request   |\n        |                      |\n        +----------------------+\n                   |\n                   v\n              +-------+\n              |       |\n              | Change|\n              +-------+\n              /       \\\n             /         \\\n            /           \\\n[3]+------------+  +---------------+  +---------------+\n   | Leader     |-&gt;| Follower      |-&gt;| Follower      |\n   | Replica    |  | Replica 1     |  | Replica 2     |\n   +------------+  +---------------+  +---------------+\n                        \\\n                         \\\n                          v\n[4]                      O  +-----------+\n                         /|\\ |           |\n                          |  | End User  |\n                          |  | (Read     |\n                          |  | Replica)  |\n                          +-----------+\n\n</pre> <ol> <li>User uploads a picture: The user adds a picture to their data.</li> <li>Write/Read Request: The user sends a write request to the Leader Replica to update the data with the new picture.</li> <li>Change propagation: The Leader Replica processes the change and propagates it to the Follower Replicas (Follower Replica 1 and Follower Replica 2).</li> <li>End User reads data: The end user reads the updated data, including the newly added picture, from the selected Follower Replica (in this case, Follower Replica 1).</li> </ol>"},{"location":"chapter5/#51-leaders-and-followers","title":"5.1 Leaders and Followers:","text":"<p>The chapter begins by introducing the concept of leader-based replication, where one node is responsible for accepting writes and replicating changes to the followers to ensure data consistency.</p>"},{"location":"chapter5/#52-synchronous-versus-asynchronous-replication","title":"5.2 Synchronous Versus Asynchronous Replication:","text":"<ul> <li>Synchronous replication:</li> <li>Strong consistency across replicas.</li> <li>Higher latency for write operations.</li> <li> <p>Lower fault tolerance.</p> </li> <li> <p>Asynchronous replication:</p> </li> <li>Lower latency for write operations.</li> <li>Weaker consistency across replicas.</li> <li>Higher fault tolerance.</li> </ul> <p>The choice between synchronous and asynchronous replication depends on the specific requirements of the system and the desired balance between consistency, performance, and fault tolerance.</p>"},{"location":"chapter5/#53-setting-up-new-followers","title":"5.3 Setting Up New Followers:","text":"<ol> <li>Snapshot: Take a consistent snapshot of the leader's database without locking the entire database.</li> <li>Copy: Transfer the snapshot to the new follower node.</li> <li>Connect and Request: The follower connects to the leader and requests data changes since the snapshot, using a specific position in the leader's replication log.</li> <li>Catch Up: The follower processes the backlog of data changes and continues to process new changes from the leader as they occur.</li> </ol> <p>The practical steps for setting up a follower vary by database. Some systems automate the process, while others require manual execution by an administrator.</p>"},{"location":"chapter5/#54-handling-node-outages","title":"5.4 Handling Node Outages:","text":"<ol> <li>Follower failure: Catch-up recovery: Followers can recover from a crash or temporary network interruption using their local log of data changes. They reconnect to the leader and request all data changes that occurred during their disconnection.</li> <li>Leader failure: Failover: Promoting a follower to be the new leader, reconfiguring clients to send writes to the new leader, and ensuring other followers consume data changes from the new leader. Failover can be manual or automatic, and involves:</li> <li>Determining leader failure: Typically using a timeout.</li> <li>Choosing a new leader: Through an election process or appointing a new leader.</li> <li>Reconfiguring the system: Clients send write requests to the new leader, and the old leader must become a follower recognizing the new leader.</li> <li>Failover challenges: Asynchronous replication can result in unreplicated writes or data loss; discarding writes can lead to inconsistency; split-brain scenarios can cause data loss or corruption; and choosing the right timeout for leader failure detection can impact recovery time and risk unnecessary failovers.</li> </ol> <p>Some operations teams prefer manual failovers due to these challenges. These issues are fundamental problems in distributed systems and are discussed in greater depth in Chapters 8 and 9.</p>"},{"location":"chapter5/#55-implementation-of-replication-logs","title":"5.5 Implementation of Replication Logs:","text":"<p>Replication logs serve as the foundation for leader-based replication in distributed systems, ensuring data consistency across nodes. This summary is based on the book \"Designing Data-Intensive Applications\" and is tailored for software engineers.</p> <pre>\n+-----------+       +-----------+       +-----------+\n|  Leader   | ----&gt; | Follower  | ----&gt; | Follower  |\n|           |       |           |       |           |\n+----+------+       +-----+-----+       +-----+-----+\n     |                   |                   |\n     v                   v                   v\n+------------+       +------------+       +------------+\n| Replication |       | Replication |       | Replication |\n|     Log     |       |     Log     |       |     Log     |\n+------------+       +------------+       +------------+\n</pre> <p>Replication logs are sequential records of updates in a distributed system. The book covers four types of replication logs:</p> <ol> <li>Statement-based replication:</li> </ol> <pre>\nLog Index | SQL Statement\n-------------------------\n1         | INSERT INTO users (id, name) VALUES (1, 'Alice')\n2         | UPDATE users SET name = 'Alicia' WHERE id = 1\n3         | DELETE FROM users WHERE id = 2\n</pre> <p>Records SQL statements executed on the primary node and replicates them to secondary nodes. Suitable for simple applications with deterministic SQL statements and minimal data transfer requirements.</p> <ol> <li>Write-ahead log (WAL) shipping:</li> </ol> <pre>\nLog Index | Operation | Block | Offset | Data\n---------------------------------------------\n1         | INSERT    | 5     | 1024   | {record_data}\n2         | UPDATE    | 5     | 1024   | {new_record_data}\n3         | DELETE    | 5     | 1024   |\n</pre> <p>Sends the primary node's WAL to secondary nodes, which replay the log to apply changes. Ensures strong consistency and data durability, ideal for PostgreSQL-based systems and those prioritizing minimal impact on primary node performance.</p> <ol> <li>Logical (row-based) log replication:</li> </ol> <pre>\nLog Index | Operation | Table | Row Data\n-----------------------------------------\n1         | INSERT    | users | {id: 1, name: 'Alice'}\n2         | UPDATE    | users | {id: 1, name: 'Alicia'}\n3         | DELETE    | users | {id: 2}\n</pre> <p>Captures changes made to individual rows in the primary node's data. Suitable for applications with non-deterministic operations, prioritizing performance, and requiring cross-platform compatibility.</p> <ol> <li>Trigger-based replication:</li> </ol> <pre>\nLog Index | Trigger Event | Table | Old Row Data | New Row Data\n---------------------------------------------------------------\n1         | INSERT        | users |              | {id: 1, name: 'Alice'}\n2         | UPDATE        | users | {id: 1, name: 'Alice'}  | {id: 1, name: 'Alicia'}\n3         | DELETE        | users | {id: 2}      |\n</pre> <p>Uses custom triggers to capture and propagate changes. Ideal for custom replication solutions, real-time data processing or transformation, and systems with heterogeneous databases.</p> <p>The choice of replication method depends on system requirements and constraints, such as consistency, performance, compatibility, and complexity.</p>"},{"location":"chapter5/#56-problems-with-replication-lag","title":"5.6 Problems with Replication Lag:","text":"<ul> <li>Replication is used for high availability, scalability, and reduced latency</li> <li>Leader-based replication requires writes to go through a single node, but read-only queries can go to any replica</li> <li>For workloads that consist mostly of reads and few writes, adding followers can increase the capacity for serving read-only requests</li> <li>This approach only works with asynchronous replication because synchronous replication would be unreliable</li> <li>Asynchronous replication can lead to eventual consistency, where followers may fall behind and return outdated information</li> <li>Replication lag can cause inconsistencies between the leader and followers</li> <li>Replication lag can increase with high system load or network problems, causing real problems for applications</li> </ul>"},{"location":"chapter5/#reading-your-own-writes","title":"Reading Your Own Writes:","text":"<ul> <li>Asynchronous replication can cause new data to not yet have reached the replica when the user views it shortly after making a write</li> <li>Read-after-write consistency guarantees that the user will always see any updates they submitted themselves</li> <li>Implementing read-after-write consistency in a system with leader-based replication requires various techniques, such as reading from the leader for user-modifiable data or tracking the time of the last update</li> <li> <p>Replicas distributed across multiple datacenters or accessed from multiple devices add complexity and require centralized metadata or routing requests to the datacenter containing the leader</p> </li> <li> <p>Another complication arises when the same user is accessing your service from multiple devices, for example a desktop web browser and a mobile app. In this case you may want to provide cross-device read-after-write consistency</p> </li> </ul> <p>Links to relevant Wikipedia articles: - Asynchronous replication - Consistency model - Data center</p>"},{"location":"chapter5/#monotonic-reads","title":"Monotonic Reads:","text":"<ul> <li>Reading from different asynchronous replicas can lead to a user seeing things moving backward in time</li> <li>Monotonic reads guarantee that time does not go backward when making multiple reads in sequence</li> <li>Monotonic reads are a lesser guarantee than strong consistency but stronger than eventual consistency</li> <li>One way to achieve monotonic reads is to make sure each user always makes their reads from the same replica, chosen based on a hash of the user ID</li> </ul> <pre><code>     Follower with little lag        Follower with greater lag\n+-------------------------+     +-------------------------+\n|                         |     |                         |\n| User 2345 reads comment |     |                         |\n| added by User 1234      |     |                         |\n| Result A                |     |                         |\n|                         |     |                         |\n+-------------------------+     |                         |\n                                 |                         |\n                                 |                         |\n                                 | User 2345 reads comment |\n                                 | added by User 1234      |\n                                 | No result returned      |\n                                 |                         |\n                                 +-------------------------+\n</code></pre> <p>This diagram represents the scenario where a user (User 2345) makes two queries to two different asynchronous replicas with different replication lags. The first query (Result A) is to a follower with little lag, and returns a comment added by another user (User 1234). The second query is to a follower with greater lag, and returns no results. This leads to the impression that time has gone backward for the user. To prevent this anomaly, we need monotonic reads.</p> <p>One way of achieving monotonic reads is to make sure that each user always makes their reads from the same replica (different users can read from different replicas). For example, the replica can be chosen based on a hash of the user ID, rather than randomly. However, if that replica fails, the user\u2019s queries will need to be rerouted to another replica.</p> <p>Monotonic reads can be achieved by ensuring that each user always reads from the same replica. This can be implemented through:</p> <ol> <li> <p>Hash-based partitioning: Data is partitioned across replicas based on a hash of the user ID, ensuring that each user always reads from the same replica.</p> </li> <li> <p>Sticky sessions: A load balancer can use sticky sessions to route requests from a user to the same replica based on their initial request.</p> </li> <li> <p>Client-side routing: The client maintains state about the replicas and chooses the replica with the lowest replication lag for the user's reads.</p> </li> <li> <p>Metadata service: A metadata service maintains a mapping of user IDs to replica IDs and returns the ID of the replica that the user should read from.</p> </li> </ol> <p>The mapping of users to replicas must be consistent and not change frequently to avoid inconsistent results.</p>"},{"location":"chapter5/#consistent-prefix-reads","title":"Consistent Prefix Reads:","text":"<p>Inconsistent replication lag can lead to violations of causality, where reads may appear to happen before writes. This can be prevented by ensuring consistent prefix reads, which guarantees that if a sequence of writes occurs in a certain order, anyone reading those writes will see them appear in the same order. In partitioned databases, different partitions may operate independently, making it challenging to ensure consistent prefix reads. One solution is to write causally related writes to the same partition, but this may not always be efficient. Algorithms that track causal dependencies can also help prevent causality violations.</p>"},{"location":"chapter5/#510-solutions-for-replication-lag","title":"5.10 Solutions for Replication Lag:","text":"<p>eventually consistent systems </p> <p>The chapter presents various techniques for addressing replication lag and improving data consistency, such as read-after-write consistency, quorum reads and writes, and version vectors.</p> <ol> <li> <p>Read-after-write consistency: This approach ensures that when a client writes data to the system, it is only acknowledged once the write is propagated to a certain number of replicas. This guarantees that subsequent reads by the same client will return the latest written data. However, it may introduce latency during write operations, as the system needs to wait for the data to propagate.</p> </li> <li> <p>Quorum reads and writes: Quorum-based systems rely on a consensus algorithm to determine the number of replicas that must acknowledge a read or write operation before it is considered successful. A common approach is to use a majority quorum, where an operation must be acknowledged by more than half of the replicas to succeed. This method helps maintain consistency, as it is less likely that an outdated replica will be used for read operations. However, it may introduce latency, as the system needs to wait for multiple acknowledgments.</p> </li> <li> <p>Version vectors: Version vectors are data structures that keep track of the version history of each replica. They allow the system to detect and resolve conflicts arising from concurrent updates to the same data. By maintaining version information for each replica, the system can determine which replica has the most up-to-date data and use that replica for read operations. This approach can help address replication lag by ensuring that clients always read the latest data, even in the presence of network delays or other issues.</p> </li> </ol> <p>Each of these techniques comes with its own trade-offs in terms of performance, latency, and complexity. The choice of which method to use depends on the specific requirements and characteristics of the distributed system being designed.</p>"},{"location":"chapter5/#further-ideas","title":"Further Ideas","text":"<ul> <li>https://github.com/donnemartin/system-design-primer#replication</li> </ul>"},{"location":"chapter5/#resources","title":"Resources","text":"<p>Design Consitent Hashing - https://systemdesign.one/consistent-hashing-explained/</p>"}]}